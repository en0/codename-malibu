from pygame import Vector2, Surface, Rect
from pygame.event import Event
from abc import ABC, abstractmethod
from typing import Set, Iterable, Optional, Union, Generator, List, Tuple, Type, TypeVar, Callable

from .models import AudioSpec, MapSpec, ObjectSpec, ObjectData
from .enum import (
    AudioEdgeTransitionEnum,
    SceneEnum,
    GameObjectMessageEnum,
    MaterialEnum,
    DirectionEnum,
    StateEnum,
)


T_GameComponent = TypeVar("T_GameComponent", bound="IGameComponent")


class IKeyboardService(ABC):
    @abstractmethod
    def is_pressed(self, key: int) -> bool: ...
    @abstractmethod
    def is_released(self, key: int) -> bool: ...
    @abstractmethod
    def is_held(self, key: int) -> bool: ...
    @abstractmethod
    def get_pressed(self) -> Set[int]: ...
    @abstractmethod
    def get_released(self) -> Set[int]: ...
    @abstractmethod
    def get_held(self) -> Set[int]: ...
    @abstractmethod
    def update(self, events: Iterable[Event]) -> None: ...


class IAssetService(ABC):
    @abstractmethod
    def get_audio_spec(self, name: str) -> AudioSpec: ...
    @abstractmethod
    def iter_audio_specs(self) -> Generator[AudioSpec, None, None]: ...
    @abstractmethod
    def get_map_spec(self, name: str) -> MapSpec: ...
    @abstractmethod
    def get_object_spec(self, name: str) -> ObjectSpec: ...
    @abstractmethod
    def get_object_data(self, name: str) -> ObjectData: ...
    @abstractmethod
    def get_sprite_sheet(self, name: str) -> List[Surface]: ...


class ISettingsService(ABC):
    ...


class IGameScene(ABC):
    @abstractmethod
    def activate(self) -> None: ...
    @abstractmethod
    def inactivate(self) -> None: ...
    @abstractmethod
    def update(self, frame_delta: float) -> None: ...


class ISceneFactory(ABC):
    @abstractmethod
    def new(self, scene: SceneEnum) -> IGameScene: ...


class IGameService(ABC):
    @abstractmethod
    def run(self, scene: IGameScene) -> None: ...
    @abstractmethod
    def close(self) -> None: ...
    @abstractmethod
    def set_scene(self, scene: IGameScene) -> None: ...
    @abstractmethod
    def push_scene(self, scene: IGameScene) -> None: ...
    @abstractmethod
    def pop_scene(self) -> IGameScene: ...
    @abstractmethod
    def get_current_scene(self) -> IGameScene: ...


class INotifiableObject(ABC):
    @abstractmethod
    def receive_message(self, sender: object, msg_type: GameObjectMessageEnum, value: any): ...


class IGameComponent(ABC):
    @abstractmethod
    def set_parent(self, game_object: "IGameObject") -> None: ...


class IInputComponent(IGameComponent):
    @abstractmethod
    def update(self, frame_delta: float, world: "IWorldMap") -> None: ...


class IBehaviorComponent(IGameComponent):
    @abstractmethod
    def update(self, frame_delta: float, world: "IWorldMap") -> None: ...


class IGraphicsComponent(IGameComponent):
    @abstractmethod
    def render(self, gfx: "IGraphicsService"): ...


class IGameObject(ABC):
    @abstractmethod
    def get_state(self, key: StateEnum) -> Optional[any]: ...
    @abstractmethod
    def set_state(self, key: StateEnum, value: any) -> None: ...
    @abstractmethod
    def has_tag(self, tag: str) -> bool: ...
    @abstractmethod
    def add_tag(self, tag: str) -> None: ...
    @abstractmethod
    def remove_tag(self, tag: str) -> None: ...
    @abstractmethod
    def process_input(self, frame_delta: float, world: "IWorldMap"): ...
    @abstractmethod
    def update(self, frame_delta: float, world: "IWorldMap"): ...
    @abstractmethod
    def render(self, gfx: Surface): ...
    @abstractmethod
    def subscribe(self, msg_type: GameObjectMessageEnum, component: INotifiableObject): ...
    @abstractmethod
    def unsubscribe(self, msg_type: GameObjectMessageEnum, component: INotifiableObject): ...
    @abstractmethod
    def notify(self, sender: object, msg_type: GameObjectMessageEnum, value: any): ...


class IObjectFactory(ABC):
    @abstractmethod
    def new(self, name: str) -> IGameObject: ...


class IWorldMap(ABC):
    @abstractmethod
    def render(self, gfx: "IGraphicsService") -> None: ...
    @abstractmethod
    def update(self, frame_delta: float) -> None: ...
    @abstractmethod
    def is_walkable(self, rect: Rect) -> bool: ...
    @abstractmethod
    def get_material(self, rect: Rect) -> MaterialEnum: ...
    @abstractmethod
    def get_default_music(self) -> str: ...
    @abstractmethod
    def get_rect(self) -> Rect: ...
    @abstractmethod
    def objects(self) -> Iterable[IGameObject]: ...
    @abstractmethod
    def find_game_objects(self, predicate: Callable[[IGameObject], bool]) -> Iterable[IGameObject]: ...
    @abstractmethod
    def find_first_game_objects(self, predicate: Callable[[IGameObject], bool]) -> Optional[IGameObject]: ...


class IWorldFactory(ABC):
    @abstractmethod
    def build_world(self, name: str) -> IWorldMap: ...


class IAudioService(ABC):
    @abstractmethod
    def set_music(self, name: Union[str, None], edge_transition: Optional[AudioEdgeTransitionEnum] = None) -> None: ...
    @abstractmethod
    def enqueue(self, name: str, point: Vector2) -> None: ...
    @abstractmethod
    def update(self, origin: Vector2) -> None: ...
    @abstractmethod
    def set_focus(self, point: Vector2) -> None: ...


class IGraphicsService(ABC):
    @abstractmethod
    def blit(
        self,
        source: Surface,
        relative: Union[Rect, Vector2, Tuple[float, float]] = None,
        absolute: Union[Rect, Vector2, Tuple[float, float]] = None,
    ) -> None: ...
    @abstractmethod
    def fill(self, color: Tuple[int, int, int], rect: Optional[Rect] = None) -> None: ...
    @abstractmethod
    def get_world_boundary(self) -> Rect: ...
    @abstractmethod
    def set_world_boundary(self, rect: Rect) -> None: ...
    @abstractmethod
    def get_viewport(self) -> Rect: ...
    @abstractmethod
    def get_resolution(self) -> Tuple[int, int]: ...
    @abstractmethod
    def set_focus(self, point: Union[Vector2, Tuple[float, float]]) -> None: ...
    @abstractmethod
    def get_hw_surface(self) -> Surface: ...
    @abstractmethod
    def compute_absolute(self, rel: Union[Rect, Vector2, Tuple[float, float]]) -> Tuple[float, float]: ...
    @abstractmethod
    def compute_absolute_vector(self, rel: Vector2) -> Vector2: ...
    @abstractmethod
    def compute_absolute_rect(self, rel: Rect) -> Rect: ...


class IAnimation(ABC):
    @property
    @abstractmethod
    def complete(self) -> bool: ...
    @property
    @abstractmethod
    def name(self) -> str: ...
    @property
    @abstractmethod
    def sprite(self) -> Surface: ...
    @property
    @abstractmethod
    def bounding_box(self) -> Rect: ...
    @property
    @abstractmethod
    def footprint(self) -> Rect: ...
    @abstractmethod
    def update(self, frame_delta: float): ...
